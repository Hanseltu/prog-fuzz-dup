"[void] [f] []([]) { [] }"
"[]; []"
"[]; []; [];"
"[]; []; []; []; [];"
"[], []"
"{ [] }"
"{ [], [] }"
"( [] )"
"( [], [] )"
"< [] >"
"< [], [] >"
"\[[]\]"
"[a]\[[0]\]"
"[int] [a]\[[]\] = { [0] };"
"[int] [a]\[[]\] = [{ 0 }];"
"while ([]) { []; []; [] }"
"switch [(x)] { case [0]: []; default: [] } [];"
"if ([x]) { []; []; []; } else { []; []; []; }"
"[x] ? [0] : [1]"
"typename []"
"[typename T]; [typename U]"
"[typename]... []"
"..."
"template<[typename T]> [struct {}];"
"template<[typename T]> struct [s] { [] };"
"template<[typename T]> [void] [f] ([]) { [] }"
".[x] = [0]"
"[] [int] [x]"
"[] [int] *[x]"
"[] [int] &[x]"
"[] [float] [x]"
"[] [double] [x]"
"[] struct [s] [{}] []"
"[] struct [s] { [] } []"
"[] struct [s] [{}]; struct [t]: [s] [{}] []"
"[] struct [s] [{}]; struct [t]: [s] { [] } []"
"[] struct [s] { [] }; struct [t]: [s] [{}] []"
"[] struct [s] { [] }; struct [t]: [s] { [] } []"
"[] class [s] [{}] []"
"[] class [s] { [] } []"
"[] union [s] [{}] []"
"[] union [s] { [] } []"
"[] enum [s] [{}] []"
"[] enum [s] { [] } []"
"[] [s](): [f]([x]) { [] }"
"[] ~[s]() { [] }"
"public: []"
"private: []"
"operator+([])"
"[0] + [0]"
"[0] - [0]"
"[0] << [0]"
"[0] >> [0]"
"[0] * [0]"
"[1.2345] * [0]"
"[0] / [0]"
"~[0]"
"[0] && [0]"
"[0] || [0]"
"[char] []*"
"[char] []&"
"[char] []&&"
"[int] [] && [x]"
"const []"
"restrict []"
"volatile []"
"mutable []"
"register []"
"thread_local []"
"noexcept []"
"typeid([])"
"virtual []"
"export []"
"friend []"
"reinterpret_cast<[int]>([x])"
"static_cast<[int]>([x])"
"const_cast<[int]>([x])"
"dynamic_cast<[int]>([x])"
"[void] [f]([]) const = 0;"
"virtual [void] [f]([]) = 0;"
"constexpr [int] [f]([]) { return [0]; }"
"constexpr [int] f([]) { return [0]; } void [g]([]) { f([]); }"
"[f]([]);"
"\[[]\] ([]) {[]}"
"([x] = [0])"
"([x] == [0])"
"([x] % [0])"
"([x] %= [0])"
"([x] < [0])"
"([x] > [0])"
"unsigned [int]"
"unsigned long long int"
"long double"
"short"
"({ []; 0 })"
"[unsigned int] [b]:[1];"
"asm [volatile] (\"[]\" : \"=r\" ([x]) : \"r\" ([y])"
"[T]::[x]"
"&[x]"
"*[x]"
"[x].[x]"
"[x]->[x]"
"[extern] [void]"
"[extern]"
"[static] [void]"
"[static]"
"[inline] [void]"
"[inline]"
"typeof([x])"
"typeof [x]"
"sizeof([x])"
"sizeof [x]"
"decltype([x])"
"alignof([x])"
"default:"
"([void]) [x]"
"[f]<[]>([])"
"[f][<>]([])"
"[int] [a]\[\] = [{}];"
"[int] [a]\[\] = { [] };"
"a"
"&a"
"x"
"&x"
"y"
"&y"
"f"
"&f"
"t"
"&t"
"T"
"&T"
"s"
"&s"
"-1ULL"
"-1"
"0"
"1"
"2"
".1"
-.3"
".1f"
"-.3f"
"1e9"
"1e15"
"1e31"
"1e67"
"1e91"
"l:"
"goto [l]; []"
"&&[l]"
"auto [x] = [f()]; []"
"auto [x] = [f]([]); []"
"[f]([])"
"break; []"
"continue; []"
"return [0]; []"
"[]; return [0];"
"namespace { []; []; []; []; [] } []; []"
"using [t] = [T]; []"
"[]; try { []; []; []; } catch ([int] [x]) { []; []; []; } [];"
"new [x][()]"
"new [x]([])"
"delete [x]"
"throw [x]"
"static_assert([1])"
"typedef [int] [t]; []"

# callbacks
"[void] (*[cb])([])"
"[void] (*[cb])([int] x)"
"[cb]->([])"
"[cb]->([x])"
"[] [void] [f] []([void] (*[cb])([])) [] { []; [cb]->([]); [] }"
"struct [s] { []; [int] [f]; [void] m []([]) []; []; }"
"&[s]::[f]"
"&[s]::[m]"
"(*[s])->[cb]"

# attributes
"__attribute__ (([]))"
"__attribute__ ((noinline([])))"
#"__attribute__ ((vector_size ([4])))"
#"__attribute__ ((noinline))"
#"__attribute__ ((noclone))"
#"__attribute__ ((aligned([16])))"
#"__attribute__ ((common))"
#"__attribute__ ((nocommon))"
#"__attribute__ ((sysv_abi))"
#"__attribute__ ((__naked__))"

# from gcc test suite
#"extern void abort (void) __attribute__ ((__noreturn__)); [int] [f] ([int] i) { if ([i]) return [i]; abort() }"
#"extern int foo1(); extern int foo2(); void foo(int n, int b) { int i, a; foo1(); a = (long)(b * ((double) [0.1])); for (i = 0; i < n; ++i) { foo2(a); [] } [] }"
#"typedef struct { unsigned char b0:1; unsigned char b[1]:1; [] } BitField; char acDummy\[0xf0\] __attribute__ ((__BELOW100__)); BitField B100A __attribute__ ((__BELOW100__)) = { 1, 0, [] }; char * Do(void) { if (B100A.b1) { [] } }"
#"extern void exit (int); typedef [long] [__m128i] __attribute__ ((__vector_size__ ([16]), [__may_alias__])); union { [__m128i] [i_align]; [long] i64\[[10240]\]; } a, b, c, d; void imul64 (void) { int i; for (i = 0; i < [10240]; [i++]) a.i64\[i\] = b.i64\[i\] * c.i64\[i\]; } int main () { imul64 (); exit (0); }"
#"[void *] p; [void] foo ([long unsigned int] len) { if ([len] < [2000 / sizeof (void *)]) p = __builtin_alloca (len * sizeof ([void *]));  else  p = __builtin_malloc (len * sizeof ([void *])); }"
#"template < [typename T] > struct na { typedef T * p; template < typename > struct r { typedef na o;}; }; template < typename T > struct a:public na < T > { [] }; template < typename T, typename c > struct v { typedef typename c::template r < [T] >::o t; struct { typename [t::p] _ms; typename [t::p] _mf; typename [t::p] _me; [];  }; }; template < typename T, typename c = a < T > >[struct V:v < T, c >] { typedef [v < T, c >] _Base; V ([]):_Base ([]) { [] } ~V(); []; }; struct l { l (int); V< struct _g >cs[]; V< [float] >db; }; l::l (int) { [] }"
#"struct A; extern struct A *a; struct A { [] } __attribute__((packed)); struct B __attribute__((aligned (sizeof (int)))); extern struct B *b; struct B { [int] i; []; []} __attribute__((packed)); int main() { [struct A] a; [struct B] b; return [0]; []; [] }"

# new
#"template <typename ... Args> struct pick_first []; template <typename T, typename ... Args > struct pick_first<T, Args ...> { using [type] = [T]; []; }; []; template <typename ... Args> using pick_first_t = typename pick_first<Args...>::type; []; template <typename Callable> struct deduce_first_parameter { private: template <typename Func, template <typename ...> typename [Operation]> struct extract_function []; []; template <typename R, typename ... Args, template <typename ...> typename Operation> struct extract_function<R(Args...), Operation> [] { using type = typename Operation<Args...>::type; []; }; template <typename C, typename R, typename ... Args, template <typename ...> typename Operation> [] struct extract_function<R (C::*)(Args...), Operation> [] { using type = typename Operation<Args...>::type; []; }; template <typename Func, template <typename ...> typename Operation> []  using extract_function_t = typename extract_function<Func, Operation>::[type]; []; public: using type = [] extract_function_t<[decltype](&[Callable]::[operator]([])), [pick_first]> []; []; }; []; template <typename R, typename ... InputArgs> [] struct deduce_first_parameter<R(InputArgs...)> { using type = pick_first_t<InputArgs...>; []; }; [];"

# builtins (https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html)
"__builtin_alloca([1])"
#"__builtin_alloca_with_align([1], [8])"
#"__builtin_alloca_with_align_and_max([1], [8], [16])"
"__builtin_types_compatible_p([int], [float])"
#"__builtin_call_with_static_chain([f()], &f)"
"__builtin_choose_expr([0], [0], [1])"
#"__builtin_tgmath()"
#"__builtin_complex([0], [0])"
#"__builtin_constant_p([0])"
#"__builtin_expect([0], [0])"
#"__builtin_trap()"
"__builtin_unreachable()"
#"__builtin_assume_aligned([&x], [4])"
#"__builtin_assume_aligned([&x], [4], [0])"
#"__builtin_LINE()"
#"__builtin_FUNCTION()"
#"__builtin_FILE()"
"__builtin___clear_cache([&x], [&x])"
"__builtin_prefetch([&x])"
#"__builtin_huge_val()"
#"__builtin_huge_valf()"
#"__builtin_huge_vall()"
#"__builtin_huge_valfn()"
#"__builtin_huge_valfnx()"
#"__builtin_fpclassify([0], [1], [2], [3], [4], [x])"
"__builtin_inf()"
#"__builtin_infd32()"
#"__builtin_infd64()"
#"__builtin_infd128()"
#"__builtin_inff()"
#"__builtin_infl()"
#"__builtin_inffn()"
#"__builtin_inffnx()"
#"__builtin_isinf_sign([x])"
#"__builtin_nan([\"\"])"
#"__builtin_nand32([\"\"])"
#"__builtin_nand64([\"\"])"
#"__builtin_nand128([\"\"])"
#"__builtin_nanf([\"\"])"
#"__builtin_nanl([\"\"])"
#"__builtin_nans([\"\"])"
#"__builtin_ffs([x])"
#"__builtin_clz([x])"
#"__builtin_ctz([x])"
#"__builtin_clrsb([x])"
"__builtin_popcount([x])"
#"__builtin_parity([x])"
#"__builtin_ffsl([x])"
#"__builtin_clzl([x])"
#"__builtin_clrsbl([x])"
#"__builtin_popcountl([x])"
#"__builtin_parityl([x])"
#"__builtin_ffsll([x])"
#"__builtin_clzll([x])"
#"__builtin_ctzll([x])"
#"__builtin_clrsbll([x])"
#"__builtin_popcountll([x])"
#"__builtin_parityll([x])"
#"__builtin_powi([x], [x])"
#"__builtin_powif([x], [x])"
#"__builtin_bswap16([x])"
#"__builtin_bswap32([x])"
#"__builtin_bswap64([x])"
"__builtin_extend_pointer([&x])"

# inline asm
"int main() { int x; long y; short z; char w; float f; double d; void *p; l: []; []; []; []; []; []; []; []; }"
"{ []; []; []; []; }"
"for (unsigned int i = [0]; i < [5]; [i++]) { []; []; []; []; []; []; []; []; }"
"[], []"
"[x]"
"&[x]"
"&[l]"
"&&[l]"
"[y][]"
"[z][]"
"[w][]"
"[f][]"
"[d][]"
"[p][]"
"[g][]"
"[0][]"
"[z][]"
"[l][]"
"[]Ir"
"[+]rm"
"[=]rm"
"[+]m"
"[=]m"
"[]ae"
"[]0"
"[+]f"
"[=]f"
"[]q"
"[=]"
"[&]"
"[+]"
"asm [volatile] (\"\" : [] : [] : [])"
"asm [goto] (\"\" : [] : [] : [])"
"(void *) []"
"(int *) []"
"(int) []"
"(float) []"
"goto"
"\"[=][&][t]\" ([x])"
"\"[=][r]\" ([x])"
"\"[+][r]\" ([x])"
"\"[&][r]\" ([x])"
"\"[r]\" ([x])"
"[\"memory\"]"
"[\"cc\"]"
"__builtin_constant_p([0])"

"({ union { []; typeof([x]) __val; [char] __c\[1\]; } __u; *([unsigned char] *) __u.__c = *([volatile unsigned char] *) &([x]); __u.__val; })"
"({ [unsigned long] __ptr; __ptr = ([unsigned long]) ([x]); ([] typeof([x])) (__ptr + ([0])); })"
"((void) sizeof(char\[1 - 2 * [x]\]))"
"[]; do { []; asm goto([x]); asm (\"\"); []; } while ([0]); []"
"[]; asm(\"\" : \"[=a]\"([x]), \"[=d]\"([x]) : \"[r]\" ([x]), \"[0]\" ([x]), \"1\" ([x])); []"
"([x] != [0] && (([x] & ([x] - [1])) == [0]))"
